import java_cup.runtime.*;
import java.io.*;

// Keywords.
terminal LET, INT, FLOAT, BOOL, CHAR, STRING, FOR, RETURN, INPUT, OUTPUT, PRINCIPAL;
terminal LOOP, DECIDE, ELSE, TRUE, FALSE, VOID, OF, END, EXIT, WHEN, STEP, TO, DOWNTO;
terminal DO, BREAK;

// Symbols.
terminal SIGMA, DOLLAR, LPAREN, RPAREN, LBLOCK, RBLOCK, ASSIGN, PLUS, MINUS, MULT;
terminal DIV, MOD, POW, AND, OR, EQ, NEQ, GT, LT, GE, LE, COMMA, ARROW, LBRACKET;
terminal RBRACKET, DIVINT, INC, DEC;

// Identifier and literals.
terminal ID, INT_LIT, FLOAT_LIT, CHAR_LIT, STRING_LIT;

// For error recovering.
terminal LEXICAL_ERROR;

non terminal program, global_vars, global_var, functions, function, params, param, main;
non terminal type_nt,type_fn, array_decl, init_nt, expr, or_expr, and_expr, lp_rel_expr;
non terminal hp_rel_expr, logic_neg, adit_expr, mult_expr, unary_minus, unary_expr;
non terminal num_lit, power_expr, inc_dec_expr, primary_expr, code_block, statement;
non terminal sentence, control_structure, var_creation, var_assignment, function_call;
non terminal literal_params, inputfn, outputfn, output_value, code_block_return, decide;
non terminal decide_options, decide_option, decide_else, loop_nt, for_nt, cs_code_block;

precedence left OR;
precedence left AND;
precedence left EQ, NEQ;
precedence left LT, GT, LE, GE;
precedence left PLUS, MINUS;
precedence left MULT, DIV, DIVINT, MOD;
precedence right POW;

start with program;

program ::= global_vars functions main ;

global_vars ::= global_var global_vars | ; // Intentionally left empty.

global_var ::= LET type_nt ID DOLLAR
             | LET type_nt array_decl DOLLAR
             | LET type_nt ID init_nt DOLLAR
             | LET type_nt array_decl init_nt DOLLAR ;

main ::= VOID PRINCIPAL LBLOCK code_block RBLOCK ;

type_nt ::= INT | FLOAT | BOOL | CHAR | STRING ;
array_decl ::= ID LBRACKET adit_expr RBRACKET ;
init_nt ::= ASSIGN expr ;

expr ::= or_expr ;

or_expr ::= or_expr OR and_expr
          | and_expr ;

and_expr ::= and_expr AND lp_rel_expr
           | lp_rel_expr ;

// Low priority relational expression (==, !=).
lp_rel_expr ::= hp_rel_expr EQ hp_rel_expr
              | hp_rel_expr NEQ hp_rel_expr
              | hp_rel_expr ;


// High priority relational expression (>, <, etc).
hp_rel_expr ::= adit_expr GT adit_expr
              | adit_expr GE adit_expr
              | adit_expr LT adit_expr
              | adit_expr LE adit_expr
              | adit_expr ;
              // | logic_neg
              // | TRUE | FALSE | CHAR_LIT | STRING_LIT ;
// These last 2 production bodies were disabled because they attempt to
// do typechecking in syntax analysis.

adit_expr ::= adit_expr PLUS mult_expr
            | adit_expr MINUS mult_expr
            | mult_expr ;

mult_expr ::= mult_expr MULT unary_expr
            | mult_expr DIV unary_expr
            | mult_expr DIVINT unary_expr
            | mult_expr MOD unary_expr
            | unary_expr ;

unary_expr ::= logic_neg | unary_minus | power_expr ;

logic_neg ::= SIGMA ID
            | SIGMA LPAREN expr RPAREN ;

unary_minus ::= MINUS num_lit
              | MINUS LPAREN expr RPAREN ;

num_lit ::= INT_LIT | FLOAT_LIT ;

power_expr ::= inc_dec_expr POW inc_dec_expr
             | inc_dec_expr ;

inc_dec_expr ::= ID INC
               | ID DEC
               | primary_expr ;

primary_expr ::= num_lit | CHAR_LIT | STRING_LIT | ID | TRUE | FALSE
               | function_call | array_decl
               | LPAREN expr RPAREN ;

functions ::= functions function | ; // May be no functions.

function ::= type_fn ID LPAREN params RPAREN LBLOCK code_block RBLOCK ;

type_fn ::= type_nt | VOID ;

params ::= param
         | param COMMA params
         | ; // May be no params.

param ::= type_nt ID
        | type_nt array_decl ;

code_block ::= code_block statement | ; // Empty code block.

statement ::= sentence | control_structure ;

sentence ::= var_creation
           | var_assignment DOLLAR
           | function_call DOLLAR
           | ID INC DOLLAR
           | ID DEC DOLLAR
           | inputfn DOLLAR
           | outputfn DOLLAR
           | code_block_return
           | BREAK DOLLAR
           | error:e DOLLAR {: System.err.println("Syntax error at line " + e.toString()); :} ;

inputfn ::= INPUT LPAREN ID RPAREN DOLLAR ;

outputfn ::= OUTPUT LPAREN output_value RPAREN DOLLAR ;

output_value ::= INT_LIT | FLOAT_LIT | STRING_LIT | ID ;

var_creation ::= LET type_nt ID DOLLAR
               | LET type_nt array_decl DOLLAR
               | LET type_nt var_assignment DOLLAR;

var_assignment ::= ID init_nt
                 | array_decl init_nt ;

function_call ::= ID LPAREN literal_params RPAREN ;

literal_params ::= expr
                 | literal_params COMMA expr | ;

control_structure ::= decide | loop_nt | for_nt ;

decide ::= DECIDE OF decide_options decide_else END DECIDE ;

decide_options ::= decide_option
                 | decide_option decide_options ;

decide_option ::= LPAREN expr RPAREN ARROW LBLOCK cs_code_block RBLOCK ;

decide_else ::= ELSE ARROW LBLOCK cs_code_block RBLOCK | ; // May be no else clause.

loop_nt ::= LOOP cs_code_block EXIT WHEN expr DOLLAR END LOOP ;

for_nt ::= FOR var_assignment STEP INT_LIT TO expr DO LBLOCK cs_code_block RBLOCK
         | FOR var_assignment STEP INT_LIT DOWNTO expr DO LBLOCK cs_code_block RBLOCK ;

cs_code_block ::= cs_code_block statement
                | statement ;

code_block_return ::= RETURN expr DOLLAR | RETURN DOLLAR ;
