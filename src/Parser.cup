import java_cup.runtime.*;
import java.io.*;
import java.util.HashMap;
import java.util.Stack;
import java.util.ArrayList;
import java.util.Map;

parser code {:
    Tac tac = new Tac();
    HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash;
    String globalHash = "globalIS";
    HashMap<String, String> valoresVariables = new HashMap<String, String>();

    {
        listaTablasSimbolos.put(globalHash, new ArrayList<String>());
    }

    public void imprimirTablasSimbolos(){
        for (String key: listaTablasSimbolos.keySet()) {
            System.out.println("Tabla de simbolo : " + key);
            System.out.println("Valores : ");
            for (String item : listaTablasSimbolos.get(key)) {
                System.out.println(item);
            }
            System.out.println("");
        }
    }

    public String getTipo(ArrayList<String> tablaSimbolos, String id){
        String tipo = "null";
        if (tablaSimbolos == null || id == null) return tipo;
        
        for (String token : tablaSimbolos) {
            if (token != null) {
                String[] partesToken = token.split("\\.");
                if (partesToken.length >= 2 && id.equals(partesToken[0]))
                    tipo = partesToken[1];
            }
        }
        return tipo;
    }

    private void enterScope(String scopeName) {
        currentHash = scopeName;
        if (!listaTablasSimbolos.containsKey(scopeName)) {
            listaTablasSimbolos.put(scopeName, new ArrayList<String>());
        }
        System.out.println("Entered scope: " + scopeName);
    }
    
    private void exitScope() {
        currentHash = globalHash;
    }
    
    private boolean addSymbol(String name, String type, String category) {
        if (name == null || type == null) return false;
        
        String scope = (currentHash != null) ? currentHash : globalHash;
        if (scope == null) scope = globalHash;
        
        ArrayList<String> currentScope = listaTablasSimbolos.get(scope);
        if (currentScope == null) {
            currentScope = new ArrayList<String>();
            listaTablasSimbolos.put(scope, currentScope);
        }
        
        for (String symbol : currentScope) {
            if (symbol != null) {
                String[] parts = symbol.split("\\.");
                if (parts.length >= 1 && parts[0].equals(name)) {
                    System.err.println("ERROR SEMANTICO: identificador '" + name + "' ya declarado en el scope actual");
                    return false;
                }
            }
        }
        
        String symbolEntry = name + "." + type;
        currentScope.add(symbolEntry);
        return true;
    }
    
    private boolean addSymbolWithValue(String name, String type, String value, String category) {
        if (name == null || type == null) return false;
        
        String scope = (currentHash != null) ? currentHash : globalHash;
        if (scope == null) scope = globalHash;
        
        ArrayList<String> currentScope = listaTablasSimbolos.get(scope);
        if (currentScope == null) {
            currentScope = new ArrayList<String>();
            listaTablasSimbolos.put(scope, currentScope);
        }
        
        for (String symbol : currentScope) {
            if (symbol != null) {
                String[] parts = symbol.split("\\.");
                if (parts.length >= 1 && parts[0].equals(name)) {
                    System.err.println("ERROR SEMANTICO: identificador '" + name + "' ya declarado en el scope actual");
                    return false;
                }
            }
        }
        
        String symbolEntry = name + "." + type;
        currentScope.add(symbolEntry);
        
        if (value != null && !value.equals("unknown")) {
            valoresVariables.put(scope + ":" + name, value);
        }
        
        return true;
    }
    
    private String findSymbolType(String name) {
        if (name == null) return "null";
        
        if (currentHash != null) {
            ArrayList<String> currentScope = listaTablasSimbolos.get(currentHash);
            if (currentScope != null) {
                String tipo = getTipo(currentScope, name);
                if (!tipo.equals("null")) return tipo;
            }
        }
        
        ArrayList<String> globalScope = listaTablasSimbolos.get(globalHash);
        if (globalScope != null) {
            return getTipo(globalScope, name);
        }
        
        return "null";
    }

    private String getSymbolValueFromStorage(String scope, String name) {
        if (name == null || scope == null) return "-";
        String key = scope + ":" + name;
        return valoresVariables.getOrDefault(key, "-");
    }

    private void saveTablesToFile() {
        try (PrintWriter writer = new PrintWriter(new FileWriter("tablas.txt", false))) {
            writer.println("SYMBOL TABLES");
            writer.println();
            
            for (String key: listaTablasSimbolos.keySet()) {
                writer.println("Tabla de simbolo: " + key);
                writer.println("Nombre\t\tTipo\t\tScope");
                writer.println("----------------------------------------");
                
                ArrayList<String> simbolos = listaTablasSimbolos.get(key);
                if (simbolos != null && !simbolos.isEmpty()) {
                    for (String simbolo : simbolos) {
                        if (simbolo != null && !simbolo.isEmpty()) {
                            String[] partes = simbolo.split("\\.");
                            String nombre = partes.length > 0 ? partes[0] : "unknown";
                            String tipo = partes.length > 1 ? partes[1] : "unknown";
                            
                            if (nombre.contains("tipo:")) continue;
                            
                            writer.printf("%-15s %-15s %-15s%n", nombre, tipo, key);
                        }
                    }
                } else {
                    writer.println("(sin símbolos)");
                }
                writer.println();
            }
            
            writer.println("FUNCIONES");
            writer.println("Nombre\t\tTipo Retorno\t\tScope");
            writer.println("----------------------------------------");
            for (String key: listaTablasSimbolos.keySet()) {
                ArrayList<String> simbolos = listaTablasSimbolos.get(key);
                if (simbolos != null) {
                    for (String simbolo : simbolos) {
                        if (simbolo != null && simbolo.contains("tipo:")) {
                            String tipoRetorno = simbolo.contains("tipo:main:") ? 
                                               simbolo.replace("tipo:main:", "") : 
                                               simbolo.replace("tipo:function:", "");
                            String nombreFuncion = key;
                            writer.printf("%-15s %-15s %-15s%n", nombreFuncion, tipoRetorno, key);
                        }
                    }
                }
            }
            
            System.out.println("Symbol tables saved to tablas.txt");
        } catch (IOException e) {
            System.err.println("Error saving symbol tables: " + e.getMessage());
        }
    }

    private String getSymbolValue(Symbol sym) {
        if (sym == null || sym.value == null) {
            return "unknown";
        }
        return sym.value.toString();
    }

    private String getIDValue(Object idObj) {
        if (idObj == null) {
            return "unknown";
        }
        if (idObj instanceof Symbol) {
            Symbol sym = (Symbol) idObj;
            return getSymbolValue(sym);
        }
        return idObj.toString();
    }

    private String getExprValue(Object exprObj) {
        if (exprObj == null) {
            return "unknown";
        }
        if (exprObj instanceof Symbol) {
            Symbol sym = (Symbol) exprObj;
            return getSymbolValue(sym);
        }
        return exprObj.toString();
    }

    private String extractArrayName(Object arrayDecl) {
        if (arrayDecl == null) {
            return null;
        }
        return getIDValue(arrayDecl);
    }

    private void captureVariableUsage(String name, String context) {
        if (name == null) return;
        
        String type = findSymbolType(name);
        if (!type.equals("null")) {
            // System.out.println("Variable usage: " + name + " (" + type + ") in " + context);
        } else {
            System.err.println("ERROR SEMANTICO: variable '" + name + "' no declarada en " + context);
        }
    }

    private void updateVariableValue(String name, String value) {
        if (name != null && value != null && !value.equals("unknown") && currentHash != null) {
            String key = currentHash + ":" + name;
            valoresVariables.put(key, value);
            System.out.println("Updated variable '" + name + "' value to: " + value);
        }
    }

    @Override
    public void syntax_error(Symbol cur_token) {
        if (cur_token != null) {
            int line = cur_token.left + 1;
            int col = cur_token.right + 1;
            if (cur_token.value != null) {
                System.err.println("Syntax error at line " + line + " and column " + col + ", near '" + cur_token.value + "'.");
            } else {
                System.err.println("Syntax error at line " + line + " and column " + col + ".");
            }
        } else {
            System.err.println("Syntax error at unknown location.");
        }
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        if (cur_token != null) {
            int line = cur_token.left + 1;
            int col = cur_token.right + 1;
            if (cur_token.value != null) {
                System.err.println("Syntax error at line " + line + " and column " + col + ", near '" + cur_token.value + "'. Couldn't recover.");
            } else {
                System.err.println("Syntax error at line " + line + " and column " + col + ". Couldn't recover.");
            }
        } else {
            System.err.println("Syntax error at unknown location. Couldn't recover.");
        }
    }
:}

// Keywords
terminal LET, INT, FLOAT, BOOL, CHAR, STRING, FOR, RETURN, INPUT, OUTPUT, PRINCIPAL;
terminal LOOP, DECIDE, ELSE, TRUE, FALSE, VOID, OF, END, EXIT, WHEN, STEP, TO, DOWNTO;
terminal DO, BREAK;

// Symbols
terminal SIGMA, DOLLAR, LPAREN, RPAREN, LBLOCK, RBLOCK, ASSIGN, PLUS, MINUS, MULT;
terminal DIV, MOD, POW, AND, OR, EQ, NEQ, GT, LT, GE, LE, COMMA, ARROW, LBRACKET;
terminal RBRACKET, DIVINT, INC, DEC;

// Identifier and literals
terminal String ID, INT_LIT, FLOAT_LIT, CHAR_LIT, STRING_LIT;

// For error recovering
terminal String LEXICAL_ERROR;

// Non-terminal declarations
non terminal program, global_vars, global_var, functions, function, params, param, main;
non terminal type_nt,type_fn, array_decl, init_nt;
non terminal code_block, statement;
non terminal sentence, control_structure, var_creation, var_assignment, function_call;
non terminal literal_params, inputfn, outputfn, output_value, code_block_return, decide;
non terminal decide_options, decide_option, decide_else, loop_nt, for_nt, cs_code_block;
non terminal array_lit, int_array_content, char_array_content, decide_option_cond;
non terminal decide_option_body, bool_lit;

// Res is a Record with type and reg fields.
non terminal Res expr, or_expr, and_expr, lp_rel_expr, hp_rel_expr, logic_neg;
non terminal Res adit_expr, mult_expr, unary_minus, unary_expr, power_expr;
non terminal Res inc_dec_expr, primary_expr;

// Operator precedence
precedence left OR;
precedence left AND;
precedence left EQ, NEQ;
precedence left LT, GT, LE, GE;
precedence left PLUS, MINUS;
precedence left MULT, DIV, DIVINT, MOD;
precedence right POW;

// Start symbol
start with program;

// Program structure
program ::= 
        global_vars functions main
        {:
            // saveTablesToFile();
            // imprimirTablasSimbolos();
            tac.dump();
            System.out.println("Parsing completed.");
        :} ;

// Global variables
global_vars ::= global_var global_vars | ;

// Global variable declarations
global_var ::= LET type_nt:type ID:id DOLLAR
             {:
                 String typeStr = getSymbolValue((Symbol)type);
                 String idStr = getIDValue(id);
                 if (!addSymbol(idStr, typeStr, "global_variable")) {
                     System.err.println("ERROR SEMANTICO: identificador '" + idStr + "' ya existe en scope global");
                 }
             :}
             | LET type_nt:type array_decl:arr DOLLAR
             {:
                 String typeStr = getSymbolValue((Symbol)type);
                 String arrayName = extractArrayName(arr);
                 if (arrayName != null) {
                     if (!addSymbol(arrayName, typeStr + "[]", "global_variable")) {
                         System.err.println("ERROR SEMANTICO: arreglo '" + arrayName + "' ya existe en scope global");
                     }
                 }
             :}
             | LET type_nt:type ID:id init_nt DOLLAR
             {:
                 String typeStr = getSymbolValue((Symbol)type);
                 String idStr = getIDValue(id);
                 if (!addSymbol(idStr, typeStr, "global_variable")) {
                     System.err.println("ERROR SEMANTICO: identificador '" + idStr + "' ya existe en scope global");
                 }
             :}
             | LET type_nt:type array_decl:arr init_nt DOLLAR
             {:
                 String typeStr = getSymbolValue((Symbol)type);
                 String arrayName = extractArrayName(arr);
                 if (arrayName != null) {
                     if (!addSymbol(arrayName, typeStr + "[]", "global_variable")) {
                         System.err.println("ERROR SEMANTICO: arreglo '" + arrayName + "' ya existe en scope global");
                     }
                 }
             :} ;

// Main function without parentheses
main ::= type_fn:type PRINCIPAL:id 
        {:
            String tipoFuncion = getSymbolValue((Symbol)type);
            String idStr = getIDValue(id);

            if(findSymbolType(idStr).equals("null")){
                currentHash = "principal";
                ArrayList<String> funcionMain = new ArrayList<String>();
                funcionMain.add("tipo:main:" + tipoFuncion);
                listaTablasSimbolos.put(currentHash, funcionMain);
            } else {
                System.err.println("ERROR SEMANTICO: función principal ya declarada");
            }
        :}
        LBLOCK code_block RBLOCK
        {:
            exitScope();
        :} ;

// Type definitions
type_nt ::= INT {: RESULT = new Symbol(sym.INT, "int"); :}
          | FLOAT {: RESULT = new Symbol(sym.FLOAT, "float"); :}
          | BOOL {: RESULT = new Symbol(sym.BOOL, "bool"); :}
          | CHAR {: RESULT = new Symbol(sym.CHAR, "char"); :}
          | STRING {: RESULT = new Symbol(sym.STRING, "string"); :};

// Array declaration
array_decl ::= ID:id LBRACKET adit_expr RBRACKET {: RESULT = id; :};

// Array literal
array_lit ::= LBLOCK int_array_content RBLOCK
            | LBLOCK char_array_content RBLOCK
            | LBLOCK RBLOCK // Empty array literal.
            | LBLOCK error RBLOCK ;

int_array_content ::= int_array_content COMMA INT_LIT | INT_LIT ;

char_array_content ::= char_array_content COMMA CHAR_LIT | CHAR_LIT ;

// Initialization
init_nt ::= ASSIGN expr
          | ASSIGN array_lit ;

// Expression parsing
expr ::= or_expr:e {: RESULT = e; :}
       | LEXICAL_ERROR:e {: System.err.println("Lexical error: " + e + "."); :}
       | error {: System.err.println("Malformed expression."); :};

// Logical expressions
or_expr ::= or_expr:e1 OR and_expr:e2
          | and_expr:e {: RESULT = e; :} ;

and_expr ::= and_expr AND lp_rel_expr
           | lp_rel_expr:e {: RESULT = e; :} ;

// Relational expressions
lp_rel_expr ::= hp_rel_expr EQ hp_rel_expr
              | hp_rel_expr NEQ hp_rel_expr
              | hp_rel_expr:e {: RESULT = e; :} ;

hp_rel_expr ::= adit_expr GT adit_expr
              | adit_expr GE adit_expr
              | adit_expr LT adit_expr
              | adit_expr LE adit_expr
              | adit_expr:e {: RESULT = e; :} ;

// Arithmetic expressions
adit_expr ::= adit_expr PLUS mult_expr
            | adit_expr MINUS mult_expr
            | mult_expr:e {: RESULT = e; :} ;

mult_expr ::= mult_expr:e1 MULT unary_expr:e2
            {:
              RESULT = new Res(e1.type(), tac.multOp(e1.reg(), e2.reg(), "*", e1.type()));
            :}
            | mult_expr:e1 DIV unary_expr:e2
            {:
              RESULT = new Res(e1.type(), tac.multOp(e1.reg(), e2.reg(), "div", e1.type()));
            :}
            | mult_expr:e1 DIVINT unary_expr:e2
            {:
              RESULT = new Res(e1.type(), tac.multOp(e1.reg(), e2.reg(), "intdiv", e1.type()));
            :}
            | mult_expr:e1 MOD unary_expr:e2
            {:
              RESULT = new Res(e1.type(), tac.multOp(e1.reg(), e2.reg(), "mod", e1.type()));
            :}
            | unary_expr:e {: RESULT = e; :} ;

// Unary expressions
unary_expr ::= logic_neg
             | unary_minus:m {: RESULT = m; :}
             | power_expr:e {: RESULT = e; :} ;

logic_neg ::= SIGMA ID:id
            {:
                String idStr = getIDValue(id);
                String type = findSymbolType(idStr);
                if (type.equals("null")) {
                    System.err.println("ERROR SEMANTICO: variable '" + idStr + "' no declarada en condición (negación lógica)");
                }
            :}
            | SIGMA LPAREN expr RPAREN ;

unary_minus ::= MINUS INT_LIT:i {: RESULT = new Res("int", tac.minus(i, "i")); :}
              | MINUS FLOAT_LIT:f {: RESULT = new Res("float", tac.minus(f, "f")); :}
              | MINUS LPAREN expr:e RPAREN
              {:
                RESULT = new Res(e.type(), tac.minus(e.reg(), e.type()));
              :} ;

// Power expression
power_expr ::= inc_dec_expr:e1 POW inc_dec_expr:e2
             {:
               RESULT = new Res("int", tac.power(e1.reg(), e2.reg()));
             :}
             | inc_dec_expr:e {: RESULT = e; :};

// Increment/decrement expressions
inc_dec_expr ::= ID:id INC
                {:
                   String idStr = getIDValue(id);
                   captureVariableUsage(idStr, "increment");
                   RESULT = new Res("int", tac.inc(id));
               :}
               | ID:id DEC
                {:
                   String idStr = getIDValue(id);
                   captureVariableUsage(idStr, "decrement");
                   RESULT = new Res("int", tac.dec(id));
                :}
               | primary_expr:p {: RESULT = p; :} ;

// Primary expressions
// This specific production has the Res type; a Record with type and reg fields.
primary_expr ::= INT_LIT:i {: RESULT = new Res("int", tac.primary(i)); :}
               | FLOAT_LIT:f {: RESULT = new Res("float", tac.primary(f)); :}
               | CHAR_LIT:c {: RESULT = new Res("char", "not implemented yet"); :}
               | STRING_LIT:s {: RESULT = new Res("string", "not implemented yet"); :}
               | ID:id 
               {:
                   String idStr = getIDValue(id);
                   String type = findSymbolType(idStr);
                   if (type.equals("null")) {
                       System.err.println("ERROR SEMANTICO: variable '" + idStr + "' no declarada en expresión");
                   }
                   RESULT = new Res("type", tac.primary(id));

               :}
               | TRUE:e {: RESULT = new Res("bool", tac.primary("1")); :}
               | FALSE:e {: RESULT = new Res("bool", tac.primary("0")); :}
               | function_call
               | array_decl
               | LPAREN expr:e RPAREN {: RESULT = e; :};

// Function declarations
functions ::= functions function | ;

// Function definition
function ::= 
    type_fn:type ID:id
    {:
        String tipoFuncion = getSymbolValue((Symbol)type);
        String idStr = getIDValue(id);
        
        if (findSymbolType(idStr).equals("null")) {
            currentHash = idStr;
            ArrayList<String> funcionMain = new ArrayList<String>();
            funcionMain.add("tipo:function:" + tipoFuncion);
            listaTablasSimbolos.put(currentHash, funcionMain);
        } else {
            System.err.println("ERROR SEMANTICO: función '" + idStr + "' ya declarada");
        }
    :}
    LPAREN params RPAREN LBLOCK code_block RBLOCK
    {:
        exitScope();
    :};

// Function type
type_fn ::= type_nt:type {: RESULT = type; :}
          | VOID {: RESULT = new Symbol(sym.VOID, "void"); :};

// Parameters
params ::= param 
        | param COMMA params
        | ;

// Parameter definitions
param ::= type_nt:type ID:id
        {:
            String typeStr = getSymbolValue((Symbol)type);
            String idStr = getIDValue(id);
            if (!addSymbol(idStr, typeStr, "parameter")) {
                System.err.println("ERROR SEMANTICO: parámetro '" + idStr + "' ya declarado");
            }
        :}
        | type_nt:type ID:id LBRACKET RBRACKET
        {:
            String typeStr = getSymbolValue((Symbol)type);
            String idStr = getIDValue(id);
            if (!addSymbol(idStr, typeStr + "[]", "parameter")) {
                System.err.println("ERROR SEMANTICO: parámetro arreglo '" + idStr + "' ya declarado");
            }
        :} ;

// Code block
code_block ::= code_block statement | ;

// Statements
statement ::= sentence | control_structure ;

// Sentence types
sentence ::= var_creation
           | var_assignment DOLLAR
           | function_call DOLLAR
           | ID:id INC DOLLAR
               {:
                   String idStr = getIDValue(id);
                   captureVariableUsage(idStr, "increment");
               :}
           | ID:id DEC DOLLAR
               {:
                   String idStr = getIDValue(id);
                   captureVariableUsage(idStr, "decrement");
               :}
           | inputfn DOLLAR
           | outputfn DOLLAR
           | code_block_return
           | BREAK DOLLAR
           | error DOLLAR {: System.out.println("Malformed sentence."); :};

// Input function
inputfn ::= INPUT LPAREN ID:id RPAREN
           {:
               String idStr = getIDValue(id);
               captureVariableUsage(idStr, "input");
           :};

// Output function
outputfn ::= OUTPUT LPAREN output_value RPAREN 
            {:
                if (cur_token != null && cur_token.value != null) {
                    System.out.println("Output value: " + cur_token.value);
                }
            :};

// Output values
output_value ::= INT_LIT | FLOAT_LIT | STRING_LIT | ID:id 
                {:
                    String idStr = getIDValue(id);
                    captureVariableUsage(idStr, "output");
                :} 
                | TRUE | FALSE ;

// Variable creation
var_creation ::= LET type_nt:type ID:id DOLLAR
               {:
                   String typeStr = getSymbolValue((Symbol)type);
                   String idStr = getIDValue(id);
                   if (!addSymbol(idStr, typeStr, "local_variable")) {
                       System.err.println("ERROR SEMANTICO: variable local '" + idStr + "' ya declarada");
                   }
               :}
               | LET type_nt:type array_decl:arr DOLLAR
               {:
                   String typeStr = getSymbolValue((Symbol)type);
                   String arrayName = extractArrayName(arr);
                   if (arrayName != null) {
                       if (!addSymbol(arrayName, typeStr + "[]", "local_variable")) {
                           System.err.println("ERROR SEMANTICO: arreglo local '" + arrayName + "' ya declarado");
                       }
                   }
               :}
               | LET type_nt:type ID:id init_nt DOLLAR
               {:
                   String typeStr = getSymbolValue((Symbol)type);
                   String idStr = getIDValue(id);
                   String valorStr = "unknown";
                   if (!addSymbolWithValue(idStr, typeStr, valorStr, "local_variable")) {
                       System.err.println("ERROR SEMANTICO: variable local '" + idStr + "' ya declarada");
                   }
               :}
               | LET type_nt:type array_decl:arr init_nt DOLLAR
               {:
                   String typeStr = getSymbolValue((Symbol)type);
                   String arrayName = extractArrayName(arr);
                   String valorStr = "unknown";
                   if (arrayName != null) {
                       if (!addSymbolWithValue(arrayName, typeStr + "[]", valorStr, "local_variable")) {
                           System.err.println("ERROR SEMANTICO: arreglo local '" + arrayName + "' ya declarado");
                       }
                   }
               :};

// Variable assignment
var_assignment ::= ID:id ASSIGN expr:value
                {:
                     String idStr = getIDValue(id);
                     String valueStr = getExprValue(value);
                     captureVariableUsage(idStr, "assignment");
                     
                     String varType = findSymbolType(idStr);
                     
                     // if (varType.equals("null")) {
                     //     System.err.println("ERROR SEMANTICO: asignación a variable no declarada '" + idStr + "'");
                     // } else {
                     //     // Verificación básica - solo para literales conocidos
                     //     if (isLiteral(valueStr)) {
                     //         String literalType = getLiteralType(valueStr);
                     //         if (!areTypesCompatible(varType, literalType)) {
                     //             System.err.println("ERROR SEMANTICO: tipos incompatibles en asignación - variable: " + varType + ", valor: " + literalType);
                     //         }
                     //     }
                     //     // Para expresiones complejas, no podemos verificar tipos fácilmente
                     //     updateVariableValue(idStr, valueStr);
                     // }
                 :}
                 | array_decl ASSIGN expr:value ;

// Function call
function_call ::= ID:id LPAREN literal_params RPAREN 
                {:
                    String idStr = getIDValue(id);
                    captureVariableUsage(idStr, "function call");
                :};

// Literal parameters
literal_params ::= expr
                 | literal_params COMMA expr | ;

// Control structures
control_structure ::= decide | loop_nt | for_nt ;

// Decide structure (if-else)
decide ::= DECIDE OF 
          {:
              enterScope("Structure: decide");
          :}
          decide_options decide_else END DECIDE DOLLAR
          {:
              exitScope();
          :} ;

decide_options ::= decide_option
                 | decide_option decide_options ;

decide_option ::= decide_option_cond 
                 {:
                     enterScope("Branch: decide_option");
                 :}
                 decide_option_body
                 {:
                     exitScope();
                 :} ;

decide_option_cond ::= LPAREN expr RPAREN ARROW LBLOCK
                     | ID ARROW LBLOCK
                     | bool_lit ARROW LBLOCK ;

bool_lit ::= TRUE | FALSE ;

decide_option_body ::= cs_code_block RBLOCK
                     | error RBLOCK ;

decide_else ::= ELSE ARROW LBLOCK 
               {:
                   enterScope("Branch: else");
               :}
               cs_code_block RBLOCK
               {:
                   exitScope();
               :} 
               | ;

// Loop structure
loop_nt ::= LOOP 
           {:
               enterScope("Structure: loop");
           :}
           cs_code_block EXIT WHEN expr DOLLAR END LOOP DOLLAR
           {:
               exitScope();
           :} ;

// For loops
for_nt ::= FOR ID:id ASSIGN expr:init STEP INT_LIT:step TO expr:end DO LBLOCK 
          {:
              enterScope("Structure: for");
              String idStr = getIDValue(id);
              String initStr = getExprValue(init);
              if (findSymbolType(idStr).equals("null")) {
                  if (currentHash != null) {
                      listaTablasSimbolos.get(currentHash).add(idStr + ".int");
                      updateVariableValue(idStr, initStr);
                  }
              } else {
                  updateVariableValue(idStr, initStr);
              }
          :}
          cs_code_block RBLOCK DOLLAR
          {:
              exitScope();
          :}
         | FOR ID:id ASSIGN expr:init STEP INT_LIT:step DOWNTO expr:end DO LBLOCK 
          {:
              enterScope("Structure: for (downto)");
              String idStr = getIDValue(id);
              String initStr = getExprValue(init);
              if (findSymbolType(idStr).equals("null")) {
                  if (currentHash != null) {
                      listaTablasSimbolos.get(currentHash).add(idStr + ".int");
                      updateVariableValue(idStr, initStr);
                  }
              } else {
                  updateVariableValue(idStr, initStr);
              }
          :}
          cs_code_block RBLOCK DOLLAR
          {:
              exitScope();
          :} ;

// Control structure code block
cs_code_block ::= cs_code_block statement
                | statement ;

// Return statement
code_block_return ::= RETURN expr DOLLAR 
                    | RETURN DOLLAR ;
